"""Mermaid flowchart renderer with rich labels and subgraphs."""

from __future__ import annotations

import hashlib
import re
from collections import defaultdict
from pathlib import Path

from codesleuth.models import CallGraph, FunctionNode
from codesleuth.renderers.base_renderer import BaseRenderer


class MermaidRenderer(BaseRenderer):
    """Renders a :class:`CallGraph` as a Mermaid flowchart inside a Markdown file."""

    def render(self, graph: CallGraph, output_path: Path, **options) -> None:
        """Write the Mermaid diagram to *output_path* (single file mode)."""
        direction: str = options.get("direction", "TD")
        max_doc: int = options.get("max_docstring_length", 80)
        include_orphans: bool = options.get("include_orphans", False)

        lines = self._build_diagram(graph, direction, max_doc, include_orphans)
        markdown = self._wrap_markdown(lines, title="Call Graph")
        output_path.write_text(markdown, encoding="utf-8")

    def render_components(self, graph: CallGraph, output_dir: Path, **options) -> list[Path]:
        """Split *graph* into connected components and write each to a separate file.

        Creates *output_dir* if it doesn't exist.  Returns the list of files
        written (including the index).

        Parameters
        ----------
        graph:
            The full resolved call graph.
        output_dir:
            Directory where component files will be written.
        **options:
            Same options as :meth:`render`.
        """
        direction: str = options.get("direction", "TD")
        max_doc: int = options.get("max_docstring_length", 80)
        include_orphans: bool = options.get("include_orphans", False)

        output_dir.mkdir(parents=True, exist_ok=True)

        components = graph.connected_components()
        written: list[Path] = []

        # Collect metadata for the index.
        component_info: list[dict] = []

        for idx, comp in enumerate(components):
            # Skip trivial components (single node, no edges) unless orphans requested.
            if not include_orphans and not comp.resolved_edges:
                continue

            lines = self._build_diagram(comp, direction, max_doc, include_orphans)

            # Determine a human-friendly name from the files involved.
            files_in_comp = sorted({str(fn.file_path) for fn in comp.nodes})
            comp_name = self._component_name(idx, files_in_comp)
            filename = f"component_{idx:02d}_{comp_name}.md"

            title = f"Component {idx} — {comp_name}"
            markdown = self._wrap_markdown(lines, title=title)

            out_path = output_dir / filename
            out_path.write_text(markdown, encoding="utf-8")
            written.append(out_path)

            component_info.append({
                "index": idx,
                "name": comp_name,
                "filename": filename,
                "nodes": len(comp.nodes),
                "edges": len(comp.resolved_edges),
                "files": files_in_comp,
            })

        # Write index file.
        index_path = output_dir / "index.md"
        index_md = self._build_index(component_info)
        index_path.write_text(index_md, encoding="utf-8")
        written.insert(0, index_path)

        return written

    @staticmethod
    def _component_name(idx: int, files: list[str]) -> str:
        """Derive a short name for a component from its constituent files."""
        if not files:
            return "isolated"
        # Use the stem of the most common file (first one alphabetically).
        stems = [Path(f).stem for f in files[:3]]
        return "_".join(stems)

    @staticmethod
    def _build_index(components: list[dict]) -> str:
        """Build an index.md that links to all component files."""
        lines = [
            "# CodeSleuth — Call Graph Index\n",
            "_Auto-generated by [CodeSleuth](https://github.com/codesleuth)._\n",
            f"**{len(components)} connected component(s)** detected.\n",
            "| # | Component | Functions | Edges | Files |",
            "|---|-----------|----------|-------|-------|",
        ]
        for c in components:
            file_list = ", ".join(f"`{f}`" for f in c["files"][:5])
            if len(c["files"]) > 5:
                file_list += f", … (+{len(c['files']) - 5} more)"
            lines.append(
                f"| {c['index']} | [{c['name']}](./{c['filename']}) "
                f"| {c['nodes']} | {c['edges']} | {file_list} |"
            )
        lines.append("")
        return "\n".join(lines)

    # ------------------------------------------------------------------
    # Node ID generation — short IDs to keep diagram text small
    # ------------------------------------------------------------------

    def _make_id_map(self, nodes: list[FunctionNode]) -> dict[str, str]:
        """Create a mapping from FunctionNode hash-key to a short id like ``n0``, ``n1``."""
        id_map: dict[str, str] = {}
        for i, fn in enumerate(nodes):
            key = self._fn_key(fn)
            if key not in id_map:
                id_map[key] = f"n{i}"
        return id_map

    @staticmethod
    def _fn_key(fn: FunctionNode) -> str:
        """Stable hash key for a FunctionNode."""
        return f"{fn.file_path}::{fn.qualified_name}::{fn.line_number}"

    # ------------------------------------------------------------------
    # Labels — compact but informative
    # ------------------------------------------------------------------

    def _node_label(self, fn: FunctionNode, max_doc: int) -> str:
        """Build a compact label: name, location, and optional short docstring."""
        parts: list[str] = []

        # Function name (bold)
        display_name = fn.name
        if fn.class_name:
            display_name = f"{fn.class_name}.{fn.name}"
        parts.append(f"<b>{self._escape(display_name)}</b>")

        # File:line (compact)
        fname = Path(fn.file_path).name
        parts.append(f"<i>{self._escape(fname)}:{fn.line_number}</i>")

        # Docstring excerpt (short)
        if fn.docstring:
            doc = fn.docstring.split("\n")[0].strip()
            if len(doc) > max_doc:
                doc = doc[: max_doc - 1] + "…"
            if doc:
                parts.append(f"<i>{self._escape(doc)}</i>")

        return "<br/>".join(parts)

    # ------------------------------------------------------------------
    # Subgraph ID
    # ------------------------------------------------------------------

    @staticmethod
    def _subgraph_id(file_path: Path) -> str:
        """Short, deterministic subgraph id from a file path."""
        h = hashlib.md5(str(file_path).encode()).hexdigest()[:6]
        name = Path(file_path).stem
        safe = re.sub(r"[^a-zA-Z0-9_]", "_", name)
        return f"sg_{safe}_{h}"

    # ------------------------------------------------------------------
    # Diagram construction
    # ------------------------------------------------------------------

    def _build_diagram(
        self,
        graph: CallGraph,
        direction: str,
        max_doc: int,
        include_orphans: bool,
    ) -> list[str]:
        lines: list[str] = [f"flowchart {direction}"]

        # Determine which nodes to include.
        connected_keys: set[str] = set()
        for edge in graph.resolved_edges:
            connected_keys.add(self._fn_key(edge.caller))
            connected_keys.add(self._fn_key(edge.resolved_callee))  # type: ignore[arg-type]

        nodes_to_render = graph.nodes if include_orphans else [
            fn for fn in graph.nodes if self._fn_key(fn) in connected_keys
        ]

        if not nodes_to_render:
            lines.append("    NoNodes[\"No call relationships detected\"]")
            return lines

        # Build short-ID mapping.
        id_map = self._make_id_map(nodes_to_render)

        # Group nodes by file for subgraphs.
        by_file: dict[Path, list[FunctionNode]] = defaultdict(list)
        for fn in nodes_to_render:
            by_file[fn.file_path].append(fn)

        # Render subgraphs.
        for file_path in sorted(by_file.keys()):
            fns = by_file[file_path]
            sg_id = self._subgraph_id(file_path)
            sg_label = self._escape(str(file_path))
            lines.append(f"    subgraph {sg_id}[\"{sg_label}\"]")
            for fn in sorted(fns, key=lambda f: f.line_number):
                nid = id_map[self._fn_key(fn)]
                label = self._node_label(fn, max_doc)
                lines.append(f"        {nid}[\"{label}\"]")
            lines.append("    end")

        # Render edges.
        for edge in graph.resolved_edges:
            src = id_map.get(self._fn_key(edge.caller))
            dst = id_map.get(self._fn_key(edge.resolved_callee))  # type: ignore[arg-type]
            if src and dst:
                lines.append(f"    {src} -->|L{edge.line_number}| {dst}")

        return lines

    # ------------------------------------------------------------------
    # Markdown wrapper
    # ------------------------------------------------------------------

    @staticmethod
    def _wrap_markdown(diagram_lines: list[str], title: str = "Call Graph") -> str:
        body = "\n".join(diagram_lines)
        # Set maxTextSize high enough for large codebases.
        init_directive = (
            "%%{init: {"
            '"theme": "default", '
            '"maxTextSize": 200000, '
            '"flowchart": {"useMaxWidth": true}'
            "}}%%"
        )
        return (
            f"# CodeSleuth — {title}\n\n"
            "_Auto-generated by [CodeSleuth](https://github.com/codesleuth)._\n\n"
            "```mermaid\n"
            f"{init_directive}\n"
            f"{body}\n"
            "```\n"
        )

    # ------------------------------------------------------------------
    # Sanitisation
    # ------------------------------------------------------------------

    @staticmethod
    def _escape(text: str) -> str:
        """Escape characters that break Mermaid syntax."""
        return (
            text.replace("&", "&amp;")
            .replace('"', "&quot;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
        )
